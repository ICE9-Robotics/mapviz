// *****************************************************************************
//
// Copyright (c) 2015, Southwest Research Institute® (SwRI®)
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Southwest Research Institute® (SwRI®) nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL Southwest Research Institute® BE LIABLE 
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
// DAMAGE.
//
// *****************************************************************************

#ifndef MAPVIZ_PLUGINS_UGI_BASESTATION_PLUGIN_H
#define MAPVIZ_PLUGINS_UGI_BASESTATION_PLUGIN_H

// C++ standard libraries
#include <string>
#include <vector>
#include <mapviz/mapviz_plugin.h>
#include <boost/thread/mutex.hpp>

// QT libraries
#include <QGLWidget>
#include <QObject>
#include <QWidget>

// ROS libraries
#include <ros/ros.h>
#include <geometry_msgs/PoseArray.h>
#include <move_base_msgs/MoveBaseAction.h>
#include <unitree_diagnostics_msgs/Diagnostics.h>
#include <actionlib/client/simple_action_client.h>
#include <dynamic_reconfigure/DoubleParameter.h>
#include <dynamic_reconfigure/Reconfigure.h>
#include <dynamic_reconfigure/Config.h>
#include <dynamic_reconfigure/client.h>
#include <origin_transform/OriginTransformConfig.h>
#include <mjpeg_cam/mjpeg_camConfig.h>
#include <improved_local_planner/DBLocalPlannerReconfigureConfig.h>

// Mapviz libraries
#include <mapviz/map_canvas.h>

// QT autogenerated files
#include "ui_ugi_basestation_config.h"


namespace mapviz_plugins
{
  struct UgiDiagnosticsInfo
  {
    ros::Time timestamp;
    ros::Time highStateTs;
    ros::Time gpsStatusTs;
    int batterySoC = 0;
    double velocity = 0.0;
    double yawSpeed = 0.0;
    double commandVelocity = 0.0;
    double commandYawSpeed =0.0;
    int mode = -1;
    std::string gpsStatusDescription = "No fix";
    double gpsVelocity = 0.0;
    double latitude = 0.0;
    double longitude = 0.0;
    double heading = 0.0;
  };

  class UgiBaseStationPluginDynamicParam
  {
  public:
    UgiBaseStationPluginDynamicParam(ros::NodeHandle nh);
    ~UgiBaseStationPluginDynamicParam();

    void setOriginTransformParam(const origin_transform::OriginTransformConfig &config);
    bool getOriginTransformParam(origin_transform::OriginTransformConfig &config);

    void setMjpegCamParam(const mjpeg_cam::mjpeg_camConfig &config);
    bool getMjpegCamParam(mjpeg_cam::mjpeg_camConfig &config);

    void setLocalPlannerParam(const improved_local_planner::DBLocalPlannerReconfigureConfig &config);
    bool getLocalPlannerParam(improved_local_planner::DBLocalPlannerReconfigureConfig &config);

  protected:
    bool is_origin_transform_received;
    bool is_mjpeg_cam_received;
    bool is_local_planner_received;

  private:
    ros::NodeHandle nh_;

    // origin_transform
    dynamic_reconfigure::Client<origin_transform::OriginTransformConfig> origin_transform_param_client_;
    origin_transform::OriginTransformConfig origin_transform_pending_config_;
    origin_transform::OriginTransformConfig origin_transform_latest_config_;
    bool is_origin_transform_update_pending_;
    boost::mutex origin_transform_param_mutex_;
    ros::Timer origin_transform_update_timer_;

    // mjpeg_cam
    dynamic_reconfigure::Client<mjpeg_cam::mjpeg_camConfig> mjpeg_cam_param_client_;
    mjpeg_cam::mjpeg_camConfig mjpeg_cam_pending_config_;
    mjpeg_cam::mjpeg_camConfig mjpeg_cam_latest_config_;
    bool is_mjpeg_cam_update_pending_;
    boost::mutex mjpeg_cam_param_mutex_;
    ros::Timer mjpeg_cam_update_timer_;

    // local_planner
    dynamic_reconfigure::Client<improved_local_planner::DBLocalPlannerReconfigureConfig> local_planner_param_client_;
    improved_local_planner::DBLocalPlannerReconfigureConfig local_planner_pending_config_;
    improved_local_planner::DBLocalPlannerReconfigureConfig local_planner_latest_config_;
    bool is_local_planner_update_pending_;
    boost::mutex local_planner_param_mutex_;
    ros::Timer local_planner_update_timer_;

    void getLatestFromSrv();
    void originTransformTimerCallback(const ros::TimerEvent& ev = ros::TimerEvent());
    void mjpegCamTimerCallback(const ros::TimerEvent& ev = ros::TimerEvent());
    void moveBaseTimerCallback(const ros::TimerEvent& ev = ros::TimerEvent());
  };

  class UgiBaseStationPlugin : public mapviz::MapvizPlugin
  {
    Q_OBJECT

  public:     
  
    typedef actionlib::SimpleActionClient<move_base_msgs::MoveBaseAction>  MoveBaseClient; 

    UgiBaseStationPlugin();
    virtual ~UgiBaseStationPlugin();

    bool Initialize(QGLWidget* canvas);
    void Shutdown() {}

    void Draw(double x, double y, double scale);

    void Transform() {}

    void LoadConfig(const YAML::Node& node, const std::string& path);
    void SaveConfig(YAML::Emitter& emitter, const std::string& path);

    QWidget* GetConfigWidget(QWidget* parent);

  protected:
    void PrintError(const std::string& message) {}
    void PrintInfo(const std::string& message) {}
    void PrintWarning(const std::string& message) {}
    virtual bool eventFilter(QObject *object, QEvent* event) override;

    bool handleMousePress(QMouseEvent *);
    bool handleMouseRelease(QMouseEvent *);
    bool handleMouseMove(QMouseEvent *);

  private Q_SLOTS:
    void on_pushButtonNavSetGoal_toggled(bool checked);
    void on_pushButtonNavAbort_clicked();

    void on_pushButtonGpsSetDatum_clicked();

    void on_pushButtonPatrolDrawWp_toggled(bool checked);
    void on_pushButtonPatrolSendWp_clicked();
    void on_pushButtonPatrolStart_toggled(bool checked);
    void on_pushButtonPatrolAbortClear_clicked();

    void on_pushButtonModeIdle_clicked();
    void on_pushButtonModeUp_clicked();
    void on_pushButtonModeDown_clicked();
    void on_pushButtonModeDamp_clicked();
    void on_pushButtonModeRecover_clicked();
    void on_pushButtonModeLock_toggled(bool checked);

    void on_doubleSpinBoxXOffset_valueChanged(double val);
    void on_doubleSpinBoxYOffset_valueChanged(double val);
    void on_doubleSpinBoxYawOffset_valueChanged(double val);

    void on_doubleSpinBoxFwVel_valueChanged(double val);
    void on_doubleSpinBoxBwVel_valueChanged(double val);
    void on_doubleSpinBoxYawSpd_valueChanged(double val);
    void on_doubleSpinBoxLinearAcc_valueChanged(double val);
    void on_doubleSpinBoxYawAcc_valueChanged(double val);

    void on_doubleSpinBoxCamBright_valueChanged(double val);
    void on_doubleSpinBoxCamExp_valueChanged(double val);
    void on_checkBoxCamAutoExp_toggled(bool checked);

    void on_pushButtonSettingRestore_clicked();

  private:
    float arrow_angle_;
    bool is_mouse_down_ = false;
    bool monitoring_action_state_ = false;
    bool is_waypoints_ok_ = false;
    bool is_origin_transform_settings_initiated_ = false;
    bool is_mjpeg_cam_settings_initiated_ = false;
    bool is_local_planner_settings_initiated_ = false;
    int selected_waypoint_;
    UgiDiagnosticsInfo diagnostic_info_;

    std::string waypoint_frame_;
    std::vector<tf::Vector3> vertices_;
    std::vector<tf::Vector3> transformed_vertices_;

    // qt
    Ui::ugi_basestation_config ui_;
    QWidget* config_widget_;
    mapviz::MapCanvas* map_canvas_;
    QPointF arrow_tail_position_;
    QPointF mouse_down_pos_;
    qint64 mouse_down_time_;

    qint64 max_ms_;
    qreal max_distance_;

    // ros
    ros::NodeHandle nh_;
    move_base_msgs::MoveBaseAction move_base_msg_;
    ros::Publisher polygon_pub_;
    ros::Subscriber waypoints_sub_;
    ros::Subscriber diagnostics_sub_;
    ros::ServiceClient gps_set_datum_srv_client_;
    ros::ServiceClient path_stop_srv_client_;
    ros::ServiceClient path_ready_srv_client_;
    ros::ServiceClient path_reset_srv_client_;
    ros::ServiceClient uhl_mode_srv_client_;
    ros::Timer slow_timer_;
    ros::Timer fast_timer_;

    MoveBaseClient move_base_client_;

    UgiBaseStationPluginDynamicParam dynamic_param_;


    void DrawNavGoal(double x, double y, double scale);
    bool handleMousePressNavGoal(QMouseEvent *event);
    bool handleMouseReleaseNavGoal(QMouseEvent *);
    bool handleMouseMoveNavGoal(QMouseEvent *);
    void DrawWaypoints(double x, double y, double scale);
    bool handleMousePressWaypoints(QMouseEvent *event);
    bool handleMouseReleaseWaypoints(QMouseEvent *);
    bool handleMouseMoveWaypoints(QMouseEvent *);

    void slowTimerCallback(const ros::TimerEvent& ev = ros::TimerEvent() );
    void fastTimerCallback(const ros::TimerEvent& ev = ros::TimerEvent() );
    void waypointsCallback(const geometry_msgs::PoseArray::ConstPtr& msg);
    void diagnosticsCallback(const unitree_diagnostics_msgs::Diagnostics::ConstPtr& msg);
    void checkNodeAlive();
  };
}


#endif //MAPVIZ_PLUGINS_UGI_BASESTATION_PLUGIN_H
